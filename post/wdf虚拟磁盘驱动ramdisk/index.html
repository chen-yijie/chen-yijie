<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>WDF虚拟磁盘驱动(RamDisk) - 忆杰的博客 - 专注于软件逆向、调试、反调试、内核开发、硬件虚拟化</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="忆杰" /><meta name="description" content="这是寒江独钓里面第5章的例子了, 分析自DDK中的RamDisk驱动. 具体来说没有太大的用处, 只是对WDF驱动的套路有个了解吧, 但是这个WDF" /><meta name="keywords" content="忆杰的博客, 软件逆向, 调试, 反调试, 驱动开发, 应用开发, 内核开发, VT技术, 硬件虚拟化" />






<meta name="generator" content="Hugo 0.98.0 with theme even" />


<link rel="canonical" href="https://xchen.com/post/wdf%E8%99%9A%E6%8B%9F%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8ramdisk/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="WDF虚拟磁盘驱动(RamDisk)" />
<meta property="og:description" content="这是寒江独钓里面第5章的例子了, 分析自DDK中的RamDisk驱动. 具体来说没有太大的用处, 只是对WDF驱动的套路有个了解吧, 但是这个WDF" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xchen.com/post/wdf%E8%99%9A%E6%8B%9F%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8ramdisk/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2011-11-29T00:00:00+00:00" />
<meta property="article:modified_time" content="2011-11-29T00:00:00+00:00" />

<meta itemprop="name" content="WDF虚拟磁盘驱动(RamDisk)">
<meta itemprop="description" content="这是寒江独钓里面第5章的例子了, 分析自DDK中的RamDisk驱动. 具体来说没有太大的用处, 只是对WDF驱动的套路有个了解吧, 但是这个WDF"><meta itemprop="datePublished" content="2011-11-29T00:00:00+00:00" />
<meta itemprop="dateModified" content="2011-11-29T00:00:00+00:00" />
<meta itemprop="wordCount" content="7054">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="WDF虚拟磁盘驱动(RamDisk)"/>
<meta name="twitter:description" content="这是寒江独钓里面第5章的例子了, 分析自DDK中的RamDisk驱动. 具体来说没有太大的用处, 只是对WDF驱动的套路有个了解吧, 但是这个WDF"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">忆杰的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">忆杰的博客</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">WDF虚拟磁盘驱动(RamDisk)</h1>

      <div class="post-meta">
        <span class="post-time"> 2011-11-29 </span>
        <div class="post-category">
            <a href="/categories/%E6%AF%94%E8%BE%83%E7%BB%99%E5%8A%9B%E7%9A%84%E5%86%85%E6%A0%B8%E7%A8%8B%E5%BA%8F/"> 比较给力的内核程序 </a>
            </div>
          <span class="more-meta"> 约 7054 字 </span>
          <span class="more-meta"> 预计阅读 15 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>这是寒江独钓里面第5章的例子了, 分析自DDK中的RamDisk驱动. 具体来说没有太大的用处, 只是对WDF驱动的套路有个了解吧, 但是这个WDF到现在为止明显没有形成气候. 写个驱动出来, 安装都是很麻烦的事情, 哪里有NT式驱动舒服啊, 不过WDF确实是潮流, 这个也确实不能够忽略..</p>
<p>其实要说NT式驱动能够在浏览器上面显示一个磁盘的话, 这个用Nt式驱动来做也很简单, 前面几章也就做了一个模拟磁盘读写的驱动. 这个驱动的难点是建立一个文件系统, 文件系统的话是比较棘手的一个东西, 这个驱动用的是简单的AT12/16.. 所以写完感觉还是意犹未尽啊!寒江独钓也就一个WDF的例子, 所以我从网上去DOWN了一个NT式驱动的虚拟磁盘的源码, 这两天再分析分析.. </p>
<p>都说了这个驱动的难点就是建立文件系统, 其他基本上也没有什么难点, 所以最主要是要搞定FAT16的文件系统. 这个网上大把资料. 搞成FAT32也不是问题. 所以基本上没有什么好说的, 代码注释非常齐全了.</p>
<p>这边是截图和代码:<br>
        <a href="http://www.joenchen.com/JoenTools/ramdisk_wdf.rar">http://www.joenchen.com/JoenTools/ramdisk_wdf.rar</a></p>
<p><img src="images/RamDisk_wdf.jpg" alt="">  </p>
<p>这边是驱动的头文件:</p>
<p>/*
Windows 内核下最简单的虚拟磁盘驱动, 将所有的读写请求转到内存中
WDF驱动, 修改自MicroSoft的例子. 这是头文件
编译方法参见就是普通的build就可以. TAB = 8
*/</p>
<p>#ifndef _RAMDISK_H_
#define _RAMDISK_H_</p>
<p>#pragma warning(disable:4201)  // nameless struct/union warning</p>
<p>#include &lt;ntddk.h&gt;
#include &lt;ntdddisk.h&gt;</p>
<p>#pragma warning(default:4201)</p>
<p>#include &lt;wdf.h&gt;
#define NTSTRSAFE_LIB
#include &lt;ntstrsafe.h&gt;</p>
<p>#define NT_DEVICE_NAME                  L&quot;\\Device\\Ramdisk&quot;
#define DOS_DEVICE_NAME                 L&quot;\\DosDevices\\&quot;</p>
<p>#define RAMDISK_TAG                     'DmaR'  // &quot;RamD&quot;
#define DOS_DEVNAME_LENGTH              (sizeof(DOS_DEVICE_NAME)+sizeof(WCHAR)*10)
#define DRIVE_LETTER_LENGTH             (sizeof(WCHAR)*10)</p>
<p>#define DRIVE_LETTER_BUFFER_SIZE        10
#define DOS_DEVNAME_BUFFER_SIZE         (sizeof(DOS_DEVICE_NAME) / 2) + 10</p>
<p>#define RAMDISK_MEDIA_TYPE              0xF8
#define DIR_ENTRIES_PER_SECTOR          16</p>
<p>//
// 这些都是默认参数, 只有在注册表中没有该项才启用, 但是安装文件已经设置了
// 驱动的参数, 所以基本来说这个就是形同虚设
//
#define DEFAULT_DISK_SIZE               (1024*1024*512)     // 默认的磁盘大小
#define DEFAULT_ROOT_DIR_ENTRIES        512		    // 默认根目录入口
#define DEFAULT_SECTORS_PER_CLUSTER     2		    // 默认柱面扇区数量
#define DEFAULT_DRIVE_LETTER            L&quot;Z:&quot;		    // 默认盘符</p>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
typedef struct _DISK_INFO {
ULONG   DiskSize;           // 磁盘的大小以Byte计算, 所以不能够超过4G
ULONG   RootDirEntries;     // 系统上根文件系统的进入点
ULONG   SectorsPerCluster;  // 磁盘的每个族由多少个扇区组成
UNICODE_STRING DriveLetter; // 磁盘的盘符
} DISK_INFO, *PDISK_INFO;</p>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
typedef struct _DEVICE_EXTENSION {
PUCHAR              DiskImage;                  // 指向一块内存区域, 作为内存盘的实际存储空间
DISK_GEOMETRY       DiskGeometry;               // 存储内存盘的物理信息, WinDDK提供
DISK_INFO           DiskRegInfo;                // 我们自己定义的磁盘信息结构, 在安装时存放在注册表中
UNICODE_STRING      SymbolicLink;               // 共享给用户态的符号链接名称
WCHAR               DriveLetterBuffer[DRIVE_LETTER_BUFFER_SIZE];	//DiskRegInfo中的盘符的存储空间
WCHAR               DosDeviceNameBuffer[DOS_DEVNAME_BUFFER_SIZE];	//符号连接名的存放空间
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;</p>
<p>WDF_DECLARE_CONTEXT_TYPE_WITH_NAME( DEVICE_EXTENSION, DeviceGetExtension )</p>
<p>typedef struct _QUEUE_EXTENSION {
PDEVICE_EXTENSION DeviceExtension;
} QUEUE_EXTENSION, *PQUEUE_EXTENSION;</p>
<p>WDF_DECLARE_CONTEXT_TYPE_WITH_NAME( QUEUE_EXTENSION, QueueGetExtension )</p>
<p>#pragma pack(1)</p>
<p>typedef struct  _BOOT_SECTOR {
UCHAR       bsJump[3];          // 跳转指令, 跳到DBR中的引导程序
CCHAR       bsOemName[8];       // 卷的OEM名称
USHORT      bsBytesPerSec;      // 每个扇区有多少个字节
UCHAR       bsSecPerClus;       // 每个族有多少个扇区
USHORT      bsResSectors;       // 保留扇区数目, 指的是第一个FAT
UCHAR       bsFATs;             // 这个卷有多少个FAT表
USHORT      bsRootDirEnts;      // 这个卷根入口点有几个
USHORT      bsSectors;          // 这个卷有多少个扇区, 对于大于65535个的扇区卷, 这个字段为0
UCHAR       bsMedia;            // 这个卷的介质类型 RAMDISK_MEDIA_TYPE
USHORT      bsFATsecs;          // 每个FAT表占用多少个扇区
USHORT      bsSecPerTrack;      // 每个磁道有多少个扇区, 我们使用32
USHORT      bsHeads;            // 有多少个磁头, 我们使用2
ULONG       bsHiddenSecs;       // 有多少个隐藏分区, 我们使用0
ULONG       bsHugeSectors;      // 一个卷如果超过65535扇区, 会使用这字段来说明总扇区数
UCHAR       bsDriveNumber;      // 驱动器编号, 未使用
UCHAR       bsReserved1;        // 保留字段
UCHAR       bsBootSignature;    // 磁盘扩展引导区标志, Windows规定必须为 0x29 或者0x28
ULONG       bsVolumeID;         // 磁盘卷ID - set to 0x12345678
CCHAR       bsLabel[11];        // 磁盘卷标
CCHAR       bsFileSystemType[8];// 文件系统类型 - FAT12 or FAT16
CCHAR       bsReserved2[448];   // 保留
UCHAR       bsSig2[2];          // DBR结束标记, 必须以0x55AA结束 - 0x55, 0xAA
}   BOOT_SECTOR, *PBOOT_SECTOR;
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
typedef struct  _DIR_ENTRY {
UCHAR       deName[8];          // 文件名称
UCHAR       deExtension[3];     // 文件扩展名
UCHAR       deAttributes;       // 文件属性
UCHAR       deReserved;         // 系统保留
USHORT      deTime;             // 文件建立时间
USHORT      deDate;             // 文件建立日期
USHORT      deStartCluster;     // 文件第一个族的编号
ULONG       deFileSize;         // 文件大小
}   DIR_ENTRY, *PDIR_ENTRY;</p>
<p>#pragma pack()</p>
<p>//
// Directory Entry Attributes
//</p>
<p>#define DIR_ATTR_READONLY   0x01
#define DIR_ATTR_HIDDEN     0x02
#define DIR_ATTR_SYSTEM     0x04
#define DIR_ATTR_VOLUME     0x08
#define DIR_ATTR_DIRECTORY  0x10
#define DIR_ATTR_ARCHIVE    0x20</p>
<p>DRIVER_INITIALIZE DriverEntry;</p>
<p>EVT_WDF_DRIVER_DEVICE_ADD RamDiskEvtDeviceAdd;</p>
<p>EVT_WDF_DEVICE_CONTEXT_CLEANUP RamDiskEvtDeviceContextCleanup;</p>
<p>EVT_WDF_IO_QUEUE_IO_READ RamDiskEvtIoRead;
EVT_WDF_IO_QUEUE_IO_WRITE RamDiskEvtIoWrite;
EVT_WDF_IO_QUEUE_IO_DEVICE_CONTROL RamDiskEvtIoDeviceControl;</p>
<p>VOID RamDiskQueryDiskRegParameters( __in PWSTR RegistryPath, __in PDISK_INFO DiskRegInfo );</p>
<p>NTSTATUS RamDiskFormatDisk( IN PDEVICE_EXTENSION DeviceExtension );</p>
<p>BOOLEAN RamDiskCheckParameters( IN PDEVICE_EXTENSION devExt, IN LARGE_INTEGER ByteOffset, IN size_t Length );</p>
<p>#endif    // _RAMDISK_H_</p>
<p>这边是驱动的主文件:</p>
<p>/*
Windows 内核下最简单的虚拟磁盘驱动, 将所有的读写请求转到内存中
WDF驱动, 修改自MicroSoft的例子. 这是驱动主文件
编译方法参见就是普通的build就可以. TAB = 8
*/
#include &quot;ramdisk.h&quot;
#include &quot;ntintsafe.h&quot;</p>
<p>#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, RamDiskEvtDeviceAdd)
#pragma alloc_text(PAGE, RamDiskEvtDeviceContextCleanup)
#pragma alloc_text(PAGE, RamDiskQueryDiskRegParameters)
#pragma alloc_text(PAGE, RamDiskFormatDisk)
#endif</p>
<p>//===========================================================================
//	驱动入口
//===========================================================================
NTSTATUS DriverEntry( PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath ) {</p>
<pre><code>WDF\_DRIVER\_CONFIG config;

KdPrint( ( &amp;quot;Windows Ramdisk Driver - 简单的磁盘过滤框架, 是微软写得.\\n&amp;quot; ) );
KdPrint( ( &amp;quot;Built %s %s\\n&amp;quot;, \_\_DATE\_\_, \_\_TIME\_\_ ) );

//这边设置了AddDevice函数的地址, 由Pnp调用, 连卸载例程都没有
WDF\_DRIVER\_CONFIG\_INIT( &amp;amp;config, RamDiskEvtDeviceAdd );

//直接按照正常的套路返回了
return WdfDriverCreate( DriverObject, RegistryPath, WDF\_NO\_OBJECT\_ATTRIBUTES,
                        &amp;amp;config, WDF\_NO\_HANDLE );
</code></pre>
<p>}</p>
<p>//===========================================================================
//	设备读取请求, 类型NT式驱动的IRP_MJ_READ
//Queue		:队列对象
//Request	:具体的请求
//Length	:用来说明需要读写的长度
//返回值	:无
//===========================================================================
VOID RamDiskEvtIoRead( WDFQUEUE Queue, WDFREQUEST Request, size_t Length ) {</p>
<pre><code>NTSTATUS               Status = STATUS\_INVALID\_PARAMETER;
WDF\_REQUEST\_PARAMETERS Parameters;
LARGE\_INTEGER          ByteOffset;
WDFMEMORY              hMemory;

//
// 从队列扩展中获取设备扩展, 初始化时我们已经关联了设备扩展
//
PDEVICE\_EXTENSION      devExt = QueueGetExtension( Queue )-&amp;gt;DeviceExtension;

//
// 初始化参数变量, 其实就是一个清0操作
//
WDF\_REQUEST\_PARAMETERS\_INIT( &amp;amp;Parameters );

//
// 从请求中获取参数信息, 和IoGetCurrentIrpStackLocation形成对比
//
WdfRequestGetParameters( Request, &amp;amp;Parameters );

//欲读取的偏移
ByteOffset.QuadPart = Parameters.Parameters.Read.DeviceOffset;

//
//这里自己实现了一个参数检测函数, 由于读取的范围不能够超过磁盘镜像
//的大小, 并且必须以扇区对齐, 所以这里需要检测参数. 如果检测失败, 返回错误
//
if ( RamDiskCheckParameters( devExt, ByteOffset, Length ) ) {

	//
	// 从读取请求参数中获取读取缓冲区的内存句柄
	//
	Status = WdfRequestRetrieveOutputMemory( Request, &amp;amp;hMemory );
	if( NT\_SUCCESS( Status ) ) {

		//
		// 根据之前获取到的读参数进行内存Copy, 填写这个缓冲区完成读取请求
		//
		Status = WdfMemoryCopyFromBuffer( hMemory,  0,
		                                  devExt-&amp;gt;DiskImage + ByteOffset.LowPart, Length );
	}
}

KdPrint(( &amp;quot;读取请求来了一次 ByteOffset:%p Length:%d\\n&amp;quot;,(ULONG)ByteOffset.QuadPart, Length  ));

//
// 类似于这号函数IoCompleteRequest
//
WdfRequestCompleteWithInformation( Request, Status, ( ULONG\_PTR )Length );
</code></pre>
<p>}</p>
<p>//===========================================================================
//	设备写入请求, 类型NT式驱动的IRP_MJ_WRITE
//Queue		:队列对象
//Request	:具体的请求
//Length	:用来说明需要读写的长度
//返回值	:无
//===========================================================================
VOID  RamDiskEvtIoWrite(  WDFQUEUE Queue, WDFREQUEST Request,  size_t Length ) {</p>
<pre><code>NTSTATUS               Status = STATUS\_INVALID\_PARAMETER;
WDF\_REQUEST\_PARAMETERS Parameters;
LARGE\_INTEGER          ByteOffset;
WDFMEMORY              hMemory;

//
// 从队列扩展中获取设备扩展
//
PDEVICE\_EXTENSION      devExt = QueueGetExtension( Queue )-&amp;gt;DeviceExtension;

//
// 初始化参数变量, 其实就是一个清0操作
//
WDF\_REQUEST\_PARAMETERS\_INIT( &amp;amp;Parameters );

//
// 从请求中获取参数信息, 和IoGetCurrentIrpStackLocation形成对比
//
WdfRequestGetParameters( Request, &amp;amp;Parameters );

//
// 写入偏移
//
ByteOffset.QuadPart = Parameters.Parameters.Write.DeviceOffset;

//
// 检测参数是否合法
//
if ( RamDiskCheckParameters( devExt, ByteOffset, Length ) ) {

	//
	// 从写入请求参数中获取写入缓冲区的内存句柄
	//
	Status = WdfRequestRetrieveInputMemory( Request, &amp;amp;hMemory );
	if( NT\_SUCCESS( Status ) ) {

		//
		// 从虚拟磁盘中中Copy内存到R3缓冲区中
		//
		Status = WdfMemoryCopyToBuffer( hMemory, 0,
		                                devExt-&amp;gt;DiskImage + ByteOffset.LowPart, Length );
	}

}

KdPrint(( &amp;quot;写入请求来了一次 ByteOffset:%p Length:%d\\n&amp;quot;,(ULONG)ByteOffset.QuadPart, Length  ));

//
// 类似于这号函数IoCompleteRequest
//
WdfRequestCompleteWithInformation( Request, Status, ( ULONG\_PTR )Length );
</code></pre>
<p>}</p>
<p>//===========================================================================
//	设备控制请求, 类似NT式驱动的IRP_MJ_DEVICE_CONTROL
//Queue		:队列对象
//Request	:具体的请求
//Length	:用来说明需要读写的长度
//返回值	:无
//===========================================================================
VOID RamDiskEvtIoDeviceControl( WDFQUEUE Queue, WDFREQUEST Request, size_t OutputBufferLength,
size_t InputBufferLength, ULONG IoControlCode ) {</p>
<pre><code>ULONG\_PTR         information = 0;
size\_t            bufSize;
NTSTATUS          Status = STATUS\_INVALID\_DEVICE\_REQUEST;

//
// 通过队列扩展获取设备扩展
//
PDEVICE\_EXTENSION devExt = QueueGetExtension( Queue )-&amp;gt;DeviceExtension;

//
//避免不使用参数警告
//
UNREFERENCED\_PARAMETER( OutputBufferLength );
UNREFERENCED\_PARAMETER( InputBufferLength );
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//	根据不同的操作码执行不同的操作
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
switch ( IoControlCode ) {</p>
<pre><code>	//
	// 获取当前分区信息的的DeviceIoControl请求, 要处理
	//
case IOCTL\_DISK\_GET\_PARTITION\_INFO: {

	PPARTITION\_INFORMATION outputBuffer;

	//
	// 完成这个请求大部分数据来自于DBR, 所以这里获取指向DBR的指针
	//
	PBOOT\_SECTOR bootSector = ( PBOOT\_SECTOR ) devExt-&amp;gt;DiskImage;

	//
	// 欲返回信息的长度
	//
	information = sizeof( PARTITION\_INFORMATION );

	//
	// 通过框架函数来获取这个DeviceIoControl请求所携带的缓冲区
	//
	Status = WdfRequestRetrieveOutputBuffer( Request, sizeof( PARTITION\_INFORMATION ), &amp;amp;outputBuffer, &amp;amp;bufSize );
	if( NT\_SUCCESS( Status ) ) {

		//
		// 填写分区类型
		//
		outputBuffer-&amp;gt;PartitionType = ( bootSector-&amp;gt;bsFileSystemType\[4\] == &amp;#39;6&amp;#39; ) ?
		                              PARTITION\_FAT\_16 : PARTITION\_FAT\_12;

		//
		// BootIndicator为TRUE表示可引导的
		//
		outputBuffer-&amp;gt;BootIndicator       = FALSE;

		//
		// 为TRUE时,系统识别的分区类型,如果为FALSE,系统没有识别的分区类型
		//
		outputBuffer-&amp;gt;RecognizedPartition = TRUE;

		//
		// 为TRUE时, 分区信息已经改变,如果为FALSE,分区信息并没有改变
		//
		outputBuffer-&amp;gt;RewritePartition    = FALSE;

		//
		// 指定驱动器上的分区开始的字节偏移量.
		//
		outputBuffer-&amp;gt;StartingOffset.QuadPart = 0;

		//
		// 指定分区的字节的长度(磁盘大小)
		//
		outputBuffer-&amp;gt;PartitionLength.QuadPart = devExt-&amp;gt;DiskRegInfo.DiskSize;

		//
		// 隐藏分区
		//
		outputBuffer-&amp;gt;HiddenSectors       = ( ULONG ) ( 1L );

		//
		// 分区号
		//
		outputBuffer-&amp;gt;PartitionNumber     = ( ULONG ) ( -1L );

		Status = STATUS\_SUCCESS;

		KdPrint( ( &amp;quot;获取当前分区信息成功!\\n&amp;quot; ) );
	}
	break;
}
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//		获取硬盘的物理信息请求
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
case IOCTL_DISK_GET_DRIVE_GEOMETRY:  {</p>
<pre><code>	PDISK\_GEOMETRY outputBuffer;

	//
	// 这里是将要返回的信息长度
	//
	information = sizeof( DISK\_GEOMETRY );

	//
	// 通过框架函数来获取这个DeviceIoControl请求所携带的的输出缓冲区
	//
	Status = WdfRequestRetrieveOutputBuffer( Request, sizeof( DISK\_GEOMETRY ), &amp;amp;outputBuffer, &amp;amp;bufSize );
	if( NT\_SUCCESS( Status ) ) {

		//
		// 将磁盘物理结构Copy到上层设备
		//
		RtlCopyMemory( outputBuffer, &amp;amp;( devExt-&amp;gt;DiskGeometry ), sizeof( DISK\_GEOMETRY ) );
		Status = STATUS\_SUCCESS;
	}

	KdPrint( ( &amp;quot;获取硬盘的物理参数成功!\\n&amp;quot; ) );
}
break;
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//		这两个请求, 直接返回成功就可以了
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
case IOCTL_DISK_CHECK_VERIFY:</p>
<pre><code>	KdPrint( ( &amp;quot;磁盘校验, 直接返回成功!\\n&amp;quot; ) );

case IOCTL\_DISK\_IS\_WRITABLE:

	KdPrint( ( &amp;quot;确定磁盘是否可写, 返回True, 直接成功!\\n&amp;quot; ) );

	Status = STATUS\_SUCCESS;
	break;
}

//
// 类似于这号函数IoCompleteRequest
//
WdfRequestCompleteWithInformation( Request, Status, information );
</code></pre>
<p>}</p>
<p>//===========================================================================
//	设备的IRP_MJ_CLOSE消息,
//Device	:设备对象
//返回值	:无
//===========================================================================
VOID RamDiskEvtDeviceContextCleanup( IN WDFDEVICE Device ) {</p>
<pre><code>//
// 获取到设备扩展指针
//
PDEVICE\_EXTENSION pDeviceExtension = DeviceGetExtension( Device );

PAGED\_CODE();

//
// 是否掉设备扩展内存就可以了
//
if( pDeviceExtension-&amp;gt;DiskImage ) {
	ExFreePool( pDeviceExtension-&amp;gt;DiskImage );
}

KdPrint( ( &amp;quot;设备清除函数被调用一次, 释放了申请的物理内存&amp;quot; ) );
</code></pre>
<p>}</p>
<p>//===========================================================================
//	类似WDM的AddDevice函数, 由Pnp管理器调用
//Driver	:
//DeviceInit	:这个参数是WDF驱动模型自动分配出来的一个数据结构, 用于建立新设别
//===========================================================================
NTSTATUS RamDiskEvtDeviceAdd( WDFDRIVER Driver,  PWDFDEVICE_INIT DeviceInit ) {
NTSTATUS                Status;
WDFDEVICE               device;
WDFQUEUE                queue;
PQUEUE_EXTENSION        pQueueContext = NULL;
PDEVICE_EXTENSION       pDeviceExtension;
WDF_OBJECT_ATTRIBUTES   deviceAttributes;
WDF_OBJECT_ATTRIBUTES   queueAttributes;
WDF_IO_QUEUE_CONFIG     ioQueueConfig;</p>
<pre><code>//初始化我们要创建的设备名称
DECLARE\_CONST\_UNICODE\_STRING( ntDeviceName, NT\_DEVICE\_NAME );

PAGED\_CODE();
UNREFERENCED\_PARAMETER( Driver );
KdPrint( ( &amp;quot;RamDiskEvtDeviceAdd被调用!\\n&amp;quot; ) );

//指定设备名称
Status = WdfDeviceInitAssignName( DeviceInit, &amp;amp;ntDeviceName );
if ( !NT\_SUCCESS( Status ) ) {
	return Status;
}

//指定设备类型
WdfDeviceInitSetDeviceType( DeviceInit, FILE\_DEVICE\_DISK );

//设备IO操作方式
WdfDeviceInitSetIoType( DeviceInit, WdfDeviceIoDirect );
//是否是独占打开
WdfDeviceInitSetExclusive( DeviceInit, FALSE );

//初始化设备扩展
WDF\_OBJECT\_ATTRIBUTES\_INIT\_CONTEXT\_TYPE( &amp;amp;deviceAttributes, DEVICE\_EXTENSION );

//指定清除回调函数, 基本上就类似于NT驱动的IRP\_MJ\_CLOSE
deviceAttributes.EvtCleanupCallback = RamDiskEvtDeviceContextCleanup;

//属性指定完毕, 真正开始创建设备
Status = WdfDeviceCreate( &amp;amp;DeviceInit, &amp;amp;deviceAttributes, &amp;amp;device );
if ( !NT\_SUCCESS( Status ) ) {
	return Status;
}

//获取设备扩展指针
pDeviceExtension = DeviceGetExtension( device );

//将处理队列初始化为默认值
WDF\_IO\_QUEUE\_CONFIG\_INIT\_DEFAULT\_QUEUE ( &amp;amp;ioQueueConfig, WdfIoQueueDispatchSequential );

//设定3个特殊的分发函数地址
ioQueueConfig.EvtIoDeviceControl = RamDiskEvtIoDeviceControl;
ioQueueConfig.EvtIoRead          = RamDiskEvtIoRead;
ioQueueConfig.EvtIoWrite         = RamDiskEvtIoWrite;

//指定队列的扩展属性, 注意要和前面的设备扩展区分开来
WDF\_OBJECT\_ATTRIBUTES\_INIT\_CONTEXT\_TYPE( &amp;amp;queueAttributes, QUEUE\_EXTENSION );

//到这里属性就配置的差不多了, 可以创建队列了将之前我们创建的设备作为
//这个队列的父对象, 这样在设备被销毁的时候这个队列也会被销毁
Status = WdfIoQueueCreate( device, &amp;amp;ioQueueConfig, &amp;amp;queueAttributes,  &amp;amp;queue );
if ( !NT\_SUCCESS( Status ) ) {
	return Status;
}

//获取队列指针
pQueueContext = QueueGetExtension( queue );

//初始化队列扩展里的DeviceExtension项, 并将其设置为刚建立的设备
//的设备扩展, 这样以后就可以方便的通过队列扩展找到设备扩展了
pQueueContext-&amp;gt;DeviceExtension = pDeviceExtension;
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//读取注册表, 初始化和内存盘有关的一些属性
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>
<pre><code>//
// 初始化存放盘符的缓冲区
//
pDeviceExtension-&amp;gt;DiskRegInfo.DriveLetter.Buffer = ( PWSTR ) &amp;amp;pDeviceExtension-&amp;gt;DriveLetterBuffer;
pDeviceExtension-&amp;gt;DiskRegInfo.DriveLetter.MaximumLength = sizeof( pDeviceExtension-&amp;gt;DriveLetterBuffer );

//
// 获取注册表中存放的磁盘信息
// WdfDeviceGetDriver		:从设备中获取这个设备对应的驱动对象
// WdfDriverGetRegistryPath	:获取驱动对象对应的注册表项目
//
RamDiskQueryDiskRegParameters( WdfDriverGetRegistryPath( WdfDeviceGetDriver( device ) ),
                               &amp;amp;pDeviceExtension-&amp;gt;DiskRegInfo );
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//
// 分配等同磁盘大小的内存, 这边用非分页内存, 有点浪费啊
// 可以看出来, 微软的人写的代码也很一般, 这边内存分配失败, 还是会返回
// 正确, 我倒, 什么工作都没有做, 原来他们说的敲例子的人都是二等开发人员
// 还是有些道理的
//
pDeviceExtension-&gt;DiskImage = ExAllocatePoolWithTag( NonPagedPool,
pDeviceExtension-&gt;DiskRegInfo.DiskSize,  RAMDISK_TAG );
if ( pDeviceExtension-&gt;DiskImage ) {</p>
<pre><code>	UNICODE\_STRING deviceName;
	UNICODE\_STRING win32Name;

	//这里调用我们自己实现的函数来格式化内存盘
	RamDiskFormatDisk( pDeviceExtension );

	Status = STATUS\_SUCCESS;
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
// 现在开始尝试创建符号链接
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>
<pre><code>	//
	// 初始化一个内容为&amp;quot;\\\\DosDevice\\\\&amp;quot;的Unicode变量
	//
	RtlInitUnicodeString( &amp;amp;win32Name, DOS\_DEVICE\_NAME );

	//
	// 初始化一个内容为&amp;quot;\\\\Device\\\\Ramdisk\\\\&amp;quot;的Unicode变量
	//
	RtlInitUnicodeString( &amp;amp;deviceName, NT\_DEVICE\_NAME );

	//
	// 准备存放符号链接名称的缓冲区
	//
	pDeviceExtension-&amp;gt;SymbolicLink.Buffer = ( PWSTR ) &amp;amp;pDeviceExtension-&amp;gt;DosDeviceNameBuffer;
	pDeviceExtension-&amp;gt;SymbolicLink.MaximumLength = sizeof( pDeviceExtension-&amp;gt;DosDeviceNameBuffer );
	pDeviceExtension-&amp;gt;SymbolicLink.Length = win32Name.Length;

	//
	// 到这里符号连接名是&amp;quot;\\\\DosDevices\\\\&amp;quot;
	//
	RtlCopyUnicodeString( &amp;amp;pDeviceExtension-&amp;gt;SymbolicLink, &amp;amp;win32Name );

	//
	// 在上面的基础之上,读取出来我们设置的盘符 &amp;quot;\\\\DosDevice\\\\Z:\\&amp;quot;
	//
	RtlAppendUnicodeStringToString( &amp;amp;pDeviceExtension-&amp;gt;SymbolicLink,
	                                &amp;amp;pDeviceExtension-&amp;gt;DiskRegInfo.DriveLetter );

	//创建符号链接
	Status = WdfDeviceCreateSymbolicLink( device, &amp;amp;pDeviceExtension-&amp;gt;SymbolicLink );
}

return Status;
</code></pre>
<p>}</p>
<p>//===========================================================================
//	从注册表中读取磁盘的配置信息
//RegistryPath	:欲读取的注册表路径
//DiskRegInfo	:存放结果信息的结构体指针
//返回值	:无
//===========================================================================
VOID RamDiskQueryDiskRegParameters( __in PWSTR RegistryPath, __in PDISK_INFO DiskRegInfo ) {
NTSTATUS                 Status;
DISK_INFO                defDiskRegInfo;
RTL_QUERY_REGISTRY_TABLE rtlQueryRegTbl[5 + 1];  //需要一个后面为NULL</p>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
PAGED_CODE();
ASSERT( RegistryPath != NULL );</p>
<pre><code>//
// 如果读取注册表失败了, 这些就是默认参数了
//
defDiskRegInfo.DiskSize          = DEFAULT\_DISK\_SIZE;
defDiskRegInfo.RootDirEntries    = DEFAULT\_ROOT\_DIR\_ENTRIES;
defDiskRegInfo.SectorsPerCluster = DEFAULT\_SECTORS\_PER\_CLUSTER;

//初始化默认的盘符
RtlInitUnicodeString( &amp;amp;defDiskRegInfo.DriveLetter, DEFAULT\_DRIVE\_LETTER );
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//初始化欲查询的数据属性
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
RtlZeroMemory( rtlQueryRegTbl, sizeof( rtlQueryRegTbl ) );</p>
<pre><code>//
// 设置欲查询的数据
//
rtlQueryRegTbl\[0\].Flags         = RTL\_QUERY\_REGISTRY\_SUBKEY;
rtlQueryRegTbl\[0\].Name          = L&amp;quot;Parameters&amp;quot;;
rtlQueryRegTbl\[0\].EntryContext  = NULL;
rtlQueryRegTbl\[0\].DefaultType   = ( ULONG\_PTR )NULL;
rtlQueryRegTbl\[0\].DefaultData   = NULL;
rtlQueryRegTbl\[0\].DefaultLength = ( ULONG\_PTR )NULL;
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
// 欲查询的磁盘参数
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>
<pre><code>//磁盘大小
rtlQueryRegTbl\[1\].Flags         = RTL\_QUERY\_REGISTRY\_DIRECT;
rtlQueryRegTbl\[1\].Name          = L&amp;quot;DiskSize&amp;quot;;
rtlQueryRegTbl\[1\].EntryContext  = &amp;amp;DiskRegInfo-&amp;gt;DiskSize;
rtlQueryRegTbl\[1\].DefaultType   = REG\_DWORD;
rtlQueryRegTbl\[1\].DefaultData   = &amp;amp;defDiskRegInfo.DiskSize;
rtlQueryRegTbl\[1\].DefaultLength = sizeof( ULONG );

//系统上根文件系统的进入点
rtlQueryRegTbl\[2\].Flags         = RTL\_QUERY\_REGISTRY\_DIRECT;
rtlQueryRegTbl\[2\].Name          = L&amp;quot;RootDirEntries&amp;quot;;
rtlQueryRegTbl\[2\].EntryContext  = &amp;amp;DiskRegInfo-&amp;gt;RootDirEntries;
rtlQueryRegTbl\[2\].DefaultType   = REG\_DWORD;
rtlQueryRegTbl\[2\].DefaultData   = &amp;amp;defDiskRegInfo.RootDirEntries;
rtlQueryRegTbl\[2\].DefaultLength = sizeof( ULONG );

//磁盘的每个族由多少个扇区组成
rtlQueryRegTbl\[3\].Flags         = RTL\_QUERY\_REGISTRY\_DIRECT;
rtlQueryRegTbl\[3\].Name          = L&amp;quot;SectorsPerCluster&amp;quot;;
rtlQueryRegTbl\[3\].EntryContext  = &amp;amp;DiskRegInfo-&amp;gt;SectorsPerCluster;
rtlQueryRegTbl\[3\].DefaultType   = REG\_DWORD;
rtlQueryRegTbl\[3\].DefaultData   = &amp;amp;defDiskRegInfo.SectorsPerCluster;
rtlQueryRegTbl\[3\].DefaultLength = sizeof( ULONG );

//磁盘的盘符
rtlQueryRegTbl\[4\].Flags         = RTL\_QUERY\_REGISTRY\_DIRECT;
rtlQueryRegTbl\[4\].Name          = L&amp;quot;DriveLetter&amp;quot;;
rtlQueryRegTbl\[4\].EntryContext  = &amp;amp;DiskRegInfo-&amp;gt;DriveLetter;
rtlQueryRegTbl\[4\].DefaultType   = REG\_SZ;
rtlQueryRegTbl\[4\].DefaultData   = defDiskRegInfo.DriveLetter.Buffer;
rtlQueryRegTbl\[4\].DefaultLength = 0;

Status = RtlQueryRegistryValues( RTL\_REGISTRY\_ABSOLUTE | RTL\_REGISTRY\_OPTIONAL, RegistryPath,
                                 rtlQueryRegTbl, NULL, NULL );
if ( NT\_SUCCESS( Status ) == FALSE ) {

	DiskRegInfo-&amp;gt;DiskSize          = defDiskRegInfo.DiskSize;
	DiskRegInfo-&amp;gt;RootDirEntries    = defDiskRegInfo.RootDirEntries;
	DiskRegInfo-&amp;gt;SectorsPerCluster = defDiskRegInfo.SectorsPerCluster;
	RtlCopyUnicodeString( &amp;amp;DiskRegInfo-&amp;gt;DriveLetter, &amp;amp;defDiskRegInfo.DriveLetter );
}
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
KdPrint( ( &quot;在注册表中获取磁盘信息!\n&quot; ) );
KdPrint( ( &quot;磁盘大小	= 0x%lx\n&quot;, DiskRegInfo-&gt;DiskSize ) );
KdPrint( ( &quot;根目录入口	= 0x%lx\n&quot;, DiskRegInfo-&gt;RootDirEntries ) );
KdPrint( ( &quot;族扇区数	= 0x%lx\n&quot;, DiskRegInfo-&gt;SectorsPerCluster ) );
KdPrint( ( &quot;驱动器盘符	= %wZ\n&quot;,   &amp;( DiskRegInfo-&gt;DriveLetter ) ) );</p>
<pre><code>return;
</code></pre>
<p>}
//===========================================================================
//	格式化一个磁盘
//devExt	:设备扩展
//返回值	:状态
//===========================================================================
NTSTATUS RamDiskFormatDisk( IN PDEVICE_EXTENSION devExt  ) {
PUCHAR       firstFatSector;	// 指向第一个FAT表的指针
ULONG        rootDirEntries;	// 记录有多少根目录入口点
ULONG        sectorsPerCluster;	// 每个族有多少个扇区构成
USHORT       fatType;		// 记录FAT文件系统类型, FAT12/16
USHORT       fatEntries;	// 记录FAT表里面有多少个表项
USHORT       fatSectorCnt;	// 用于记录一个FAT表项需要占用多少个扇区
PDIR_ENTRY   rootDir;		// 根目录入口点</p>
<pre><code>//
// 启动扇区指针, 也就是存放的申请的内存首地址
//
PBOOT\_SECTOR bootSector = ( PBOOT\_SECTOR ) devExt-&amp;gt;DiskImage;
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
PAGED_CODE();</p>
<pre><code>//
// 确定这个盘的引导扇区是512字节, 然后清空内存
//
ASSERT( sizeof( BOOT\_SECTOR ) == 512 );
ASSERT( devExt-&amp;gt;DiskImage != NULL );

RtlZeroMemory( devExt-&amp;gt;DiskImage, devExt-&amp;gt;DiskRegInfo.DiskSize );
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//初始化磁盘物理结构
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//
// 每个扇区有512个字节
//
devExt-&gt;DiskGeometry.BytesPerSector = 512;</p>
<pre><code>//
// 每个磁道有32个扇区
//
devExt-&amp;gt;DiskGeometry.SectorsPerTrack = 32;

//
// 每个柱面有两个磁道
//
devExt-&amp;gt;DiskGeometry.TracksPerCylinder = 2;

//
// 柱面数就要由总容量计算了
//
devExt-&amp;gt;DiskGeometry.Cylinders.QuadPart = devExt-&amp;gt;DiskRegInfo.DiskSize / 512 / 32 / 2;

//
// 磁盘的类型就是我们自己定义的 RAMDISK\_MEDIA\_TYPE
//
devExt-&amp;gt;DiskGeometry.MediaType = RAMDISK\_MEDIA\_TYPE;

KdPrint( (  &amp;quot;柱面数: %ld\\n 柱面磁道数: %ld\\n 磁道扇区数: %ld\\n 扇区字节数: %ld\\n&amp;quot;,
            devExt-&amp;gt;DiskGeometry.Cylinders.QuadPart,
            devExt-&amp;gt;DiskGeometry.TracksPerCylinder,
            devExt-&amp;gt;DiskGeometry.SectorsPerTrack,
            devExt-&amp;gt;DiskGeometry.BytesPerSector ) );
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//	初始化文件系统信息
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//
// 根据用户指定的值, 初始化根目录数目
//
rootDirEntries = devExt-&gt;DiskRegInfo.RootDirEntries;</p>
<pre><code>//
// 根据用户指定值对每个族有多少个扇区进行初始化
//
sectorsPerCluster = devExt-&amp;gt;DiskRegInfo.SectorsPerCluster;

//
// 由于根目录入口点只使用32字节, 但是最少占用一个扇区,
// 这里为了充分利用空间, 在用户指定数目不合适时, 会修正这个数目
//
if ( rootDirEntries &amp;amp; ( DIR\_ENTRIES\_PER\_SECTOR - 1 ) ) {

	rootDirEntries = ( rootDirEntries + ( DIR\_ENTRIES\_PER\_SECTOR - 1 ) ) &amp;amp;
	                 ~( DIR\_ENTRIES\_PER\_SECTOR - 1 );
}

KdPrint( ( &amp;quot;根目录入口: %ld\\n 族扇区数: %ld\\n&amp;quot;,
           rootDirEntries, sectorsPerCluster  ) );
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//	我们这个磁盘不含有MBR, 直接就是从DBR开始
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//
// 这里必须使用0xEB和0x90, 这是文件系统的检查标记
//
bootSector-&gt;bsJump[0] = 0xeb;
bootSector-&gt;bsJump[1] = 0x3c;
bootSector-&gt;bsJump[2] = 0x90;</p>
<pre><code>//
// 填写OEM名称成员, 这里当然是写 JoenRam了, 刚好8个
//
bootSector-&amp;gt;bsOemName\[0\] = &amp;#39;J&amp;#39;;
bootSector-&amp;gt;bsOemName\[1\] = &amp;#39;o&amp;#39;;
bootSector-&amp;gt;bsOemName\[2\] = &amp;#39;e&amp;#39;;
bootSector-&amp;gt;bsOemName\[3\] = &amp;#39;n&amp;#39;;
bootSector-&amp;gt;bsOemName\[4\] = &amp;#39;R&amp;#39;;
bootSector-&amp;gt;bsOemName\[5\] = &amp;#39;a&amp;#39;;
bootSector-&amp;gt;bsOemName\[6\] = &amp;#39;m&amp;#39;;
bootSector-&amp;gt;bsOemName\[7\] = &amp;#39; &amp;#39;;

//
//每个扇区有多少个字节, 这个成员直接取之前初始化磁盘的信息结构
//
bootSector-&amp;gt;bsBytesPerSec = ( SHORT )devExt-&amp;gt;DiskGeometry.BytesPerSector;

//
// 这个卷只有一个保留扇区, 既DBR本身
//
bootSector-&amp;gt;bsResSectors  = 1;

//
// 和正常的卷不同, 为了节省空间, 我们只存放一份FAT表, 而不是通常的两份
//
bootSector-&amp;gt;bsFATs        = 1;

//
// 根目录的入口点数目, 由之前的的计算得知
//
bootSector-&amp;gt;bsRootDirEnts = ( USHORT )rootDirEntries;

//
// 这个磁盘的总扇区数由磁盘总大小和每个扇区的字节数计算得到 磁盘大小/扇区字节
//
bootSector-&amp;gt;bsSectors	  = ( USHORT )( devExt-&amp;gt;DiskRegInfo.DiskSize / devExt-&amp;gt;DiskGeometry.BytesPerSector );

//
// 磁盘介质类型由之前的初始化磁盘信息得到
//
bootSector-&amp;gt;bsMedia       = ( UCHAR )devExt-&amp;gt;DiskGeometry.MediaType;

//
// 每个族有多少个扇区由之前的计算值初始化得到
//
bootSector-&amp;gt;bsSecPerClus  = ( UCHAR )sectorsPerCluster;
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
// 计算这个磁盘FAT表所占用的空间
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>
<pre><code>//
// FAT表的表项数目是由总扇区数减去保留的扇区数, 再减去根目录入口点所占用
// 的扇区数, 然后除以每族的扇区数, 罪的结果需要+2, 因为FAT第0项, 第1项是保留的
//
fatEntries = ( bootSector-&amp;gt;bsSectors - bootSector-&amp;gt;bsResSectors - bootSector-&amp;gt;bsRootDirEnts /
               DIR\_ENTRIES\_PER\_SECTOR ) / bootSector-&amp;gt;bsSecPerClus + 2;

//
// 上面已经计算出了FAT表的表项数量, 根据这个表项数量首先可以决定到底是用FAT12还是FAT16
// 文件系统, 决定了文件系统就可以计算出每个FAT表的表项需要占用多少空间, 进而计算出整个FAT
// FAT表所占用的扇区数
//
if ( fatEntries &amp;gt; 4087 ) {
	fatType =  16;						//文件系统类型
	fatSectorCnt = ( fatEntries \* 2 + 511 ) / 512;		//一个表项需要占用多少个扇区
	fatEntries   = fatEntries + fatSectorCnt;		//记FAT表里面有多少个表项
	fatSectorCnt = ( fatEntries \* 2 + 511 ) / 512;		//一个FAT表项需要占用多少个扇区
} else {
	fatType =  12;
	fatSectorCnt = ( ( ( fatEntries \* 3 + 1 ) / 2 ) + 511 ) / 512;
	fatEntries   = fatEntries + fatSectorCnt;
	fatSectorCnt = ( ( ( fatEntries \* 3 + 1 ) / 2 ) + 511 ) / 512;
}
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//	接着初始化DBR的其他属性
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//
// 初始化FAT表所占用的分区数
//
bootSector-&gt;bsFATsecs       = fatSectorCnt;</p>
<pre><code>//
// 初始化DBR中每个磁道的扇区数
//
bootSector-&amp;gt;bsSecPerTrack   = ( USHORT )devExt-&amp;gt;DiskGeometry.SectorsPerTrack;

//
// 初始化磁头数, 也就是每个柱面的磁道数
//
bootSector-&amp;gt;bsHeads         = ( USHORT )devExt-&amp;gt;DiskGeometry.TracksPerCylinder;

//
// 初始化启动签名, Windows要求必须是0x28 或者0x29
//
bootSector-&amp;gt;bsBootSignature = 0x29;

//
// 卷ID, 随意了
//
bootSector-&amp;gt;bsVolumeID      = 0x12345678;

//
// 设置卷标, 随便搞了, 反正就是11字符
//
bootSector-&amp;gt;bsLabel\[0\]  = &amp;#39;J&amp;#39;;
bootSector-&amp;gt;bsLabel\[1\]  = &amp;#39;o&amp;#39;;
bootSector-&amp;gt;bsLabel\[2\]  = &amp;#39;e&amp;#39;;
bootSector-&amp;gt;bsLabel\[3\]  = &amp;#39;n&amp;#39;;
bootSector-&amp;gt;bsLabel\[4\]  = &amp;#39;D&amp;#39;;
bootSector-&amp;gt;bsLabel\[5\]  = &amp;#39;i&amp;#39;;
bootSector-&amp;gt;bsLabel\[6\]  = &amp;#39;s&amp;#39;;
bootSector-&amp;gt;bsLabel\[7\]  = &amp;#39;k&amp;#39;;
bootSector-&amp;gt;bsLabel\[8\]  = &amp;#39; &amp;#39;;
bootSector-&amp;gt;bsLabel\[9\]  = &amp;#39; &amp;#39;;
bootSector-&amp;gt;bsLabel\[10\] = &amp;#39; &amp;#39;;

//
// 设置文件系统类型
//
bootSector-&amp;gt;bsFileSystemType\[0\] = &amp;#39;F&amp;#39;;
bootSector-&amp;gt;bsFileSystemType\[1\] = &amp;#39;A&amp;#39;;
bootSector-&amp;gt;bsFileSystemType\[2\] = &amp;#39;T&amp;#39;;
bootSector-&amp;gt;bsFileSystemType\[3\] = &amp;#39;1&amp;#39;;
bootSector-&amp;gt;bsFileSystemType\[4\] = &amp;#39;?&amp;#39;;
bootSector-&amp;gt;bsFileSystemType\[5\] = &amp;#39; &amp;#39;;
bootSector-&amp;gt;bsFileSystemType\[6\] = &amp;#39; &amp;#39;;
bootSector-&amp;gt;bsFileSystemType\[7\] = &amp;#39; &amp;#39;;
bootSector-&amp;gt;bsFileSystemType\[4\] = ( fatType == 16 ) ? &amp;#39;6&amp;#39; : &amp;#39;2&amp;#39;;

//
// DBR结尾标记
//
bootSector-&amp;gt;bsSig2\[0\] = 0x55;
bootSector-&amp;gt;bsSig2\[1\] = 0xAA;
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//上面总算把这个DBR给初始化完了, 接下来需要初始化FAT表
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>
<pre><code>//
// 定位到FAT表的起始点, 这里的定位方式是利用了DBR治愈一个扇区这个条件
//
firstFatSector    = ( PUCHAR )( bootSector + 1 );

//
// 填写介质类型
//
firstFatSector\[0\] = ( UCHAR )devExt-&amp;gt;DiskGeometry.MediaType;

// 填写结束标记
//
firstFatSector\[1\] = 0xFF;
firstFatSector\[2\] = 0xFF;

if ( fatType == 16 ) {
	firstFatSector\[3\] = 0xFF;
}
</code></pre>
<p>//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//初始化根目录, 在FAT12/16文件系统中, 通常第一个根目录入口点存储了最终
//被作为卷标的目录入口点.
//&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
//
// 由于紧跟着FAT表, 所以根目录入口点的表起始位置很好找的
//
rootDir = ( PDIR_ENTRY )( bootSector + 1 + fatSectorCnt );</p>
<pre><code>//
// 初始化卷标 JoenChen
//
rootDir-&amp;gt;deName\[0\] = &amp;#39;J&amp;#39;;
rootDir-&amp;gt;deName\[1\] = &amp;#39;o&amp;#39;;
rootDir-&amp;gt;deName\[2\] = &amp;#39;e&amp;#39;;
rootDir-&amp;gt;deName\[3\] = &amp;#39;n&amp;#39;;
rootDir-&amp;gt;deName\[4\] = &amp;#39;C&amp;#39;;
rootDir-&amp;gt;deName\[5\] = &amp;#39;h&amp;#39;;
rootDir-&amp;gt;deName\[6\] = &amp;#39;e&amp;#39;;
rootDir-&amp;gt;deName\[7\] = &amp;#39;n&amp;#39;;

//
// 设置设备的扩展名称, 空着吧
//
rootDir-&amp;gt;deExtension\[0\] = &amp;#39; &amp;#39;;
rootDir-&amp;gt;deExtension\[1\] = &amp;#39; &amp;#39;;
rootDir-&amp;gt;deExtension\[2\] = &amp;#39; &amp;#39;;

//
// 将这个入口点的属性设置为卷标属性
//
rootDir-&amp;gt;deAttributes = DIR\_ATTR\_VOLUME;

KdPrint( ( &amp;quot;格式化磁盘成功!\\n&amp;quot; ) );

return STATUS\_SUCCESS;
</code></pre>
<p>}</p>
<p>//===========================================================================
//	磁盘传递的参数检测
//devExt	:设备扩展指针
//ByteOffset	:读取偏移
//Length	:读取长度
//===========================================================================
BOOLEAN RamDiskCheckParameters( PDEVICE_EXTENSION devExt, LARGE_INTEGER ByteOffset, size_t Length ) {</p>
<pre><code>//
// 读取参数检测, 如果磁盘的大小小于读取的长度, 或者偏移小于0,
// 或者偏移大于磁盘大小+读取的长度, 获取长度有没有按照扇区对齐
//
if( devExt-&amp;gt;DiskRegInfo.DiskSize &amp;lt; Length || ByteOffset.QuadPart &amp;lt; 0 ||
        ( ( ULONGLONG )ByteOffset.QuadPart &amp;gt; ( devExt-&amp;gt;DiskRegInfo.DiskSize - Length ) ) ||
        ( Length &amp;amp; ( devExt-&amp;gt;DiskGeometry.BytesPerSector - 1 ) ) ) {

	//
	// 直接返回参数错误
	//
	KdPrint( ( &amp;quot;参数错误\\nByteOffset: %x\\n Length: %d\\n&amp;quot;, ByteOffset, Length ) );

	return FALSE;
}

return TRUE;
</code></pre>
<p>}</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">忆杰</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2011-11-29
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/%E8%99%9A%E6%8B%9F%E7%A3%81%E7%9B%98%E5%85%89%E9%A9%B1filedisk/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">虚拟磁盘光驱(FileDisk)</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E9%94%AE%E7%9B%98%E8%BF%87%E6%BB%A4%E4%BA%8C%E6%8E%A5%E7%AE%A193h%E4%B8%AD%E6%96%AD/">
            <span class="next-text nav-default">键盘过滤二(接管93h中断)</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="chen-yijie/utterances-Comment"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:chen-yijie@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/chen-yijie" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/joen88" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="https://xchen.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span>忆杰</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>








</body>
</html>
